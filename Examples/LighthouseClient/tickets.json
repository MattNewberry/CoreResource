{
    "tickets": [
        {
            "ticket": {
                "original_body_html": "<div><p>Add an asynchronous image downloader and possibly a related\ncustom UIImageView (if necessary).</p>\n<p>The downloader should probably reside in a global space (e.g.,\nCoreManager), since images may finish downloading some time after\ntheir parent resource deallocates.</p></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/1",
                "permalink": "feature-add-asynchronous-image-downloaderview",
                "updated_at": "2010-03-06T19:19:41Z",
                "project_id": 48029,
                "title": "[feature] Add asynchronous image downloader/view",
                "number": 1,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "Add an asynchronous image downloader and possibly a related custom UIImageView (if necessary).\r\n\r\nThe downloader should probably reside in a global space (e.g., CoreManager), since images may finish downloading some time after their parent resource deallocates.",
                "tag": "images",
                "priority": 1,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "Add an asynchronous image downloader and possibly a related custom UIImageView (if necessary).\r\n\r\nThe downloader should probably reside in a global space (e.g., CoreManager), since images may finish downloading some time after their parent resource deallocates.",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:42:50Z"
            }
        },
        {
            "ticket": {
                "original_body_html": "<div><p>Relationship deserialization currently looks at the reverse\nrelationship and attempts to assign there, which is probably the\nwrong approach (it was easier at the time, though!)</p>\n<p>We should probably just use the regular (not inverse) setter for\ntoOnes. For toManys, we can look for addObject: methods and use\nthose if they exist; otherwise we can use more esoteric processing\n(like using the inverse setter if it's a one-many, and who knows\nwhat if it's a many-many...)</p></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/6",
                "permalink": "relationship-deserialization-is-brittle-and-only-works-for-bidirectional-relationships",
                "updated_at": "2010-03-06T16:59:29Z",
                "project_id": 48029,
                "title": "Relationship deserialization is brittle (and only works for bidirectional relationships)",
                "number": 6,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "Relationship deserialization currently looks at the reverse relationship and attempts to assign there, which is probably the wrong approach (it was easier at the time, though!)\r\n\r\nWe should probably just use the regular (not inverse) setter for toOnes. For toManys, we can look for addObject: methods and use those if they exist; otherwise we can use more esoteric processing (like using the inverse setter if it's a one-many, and who knows what if it's a many-many...)",
                "tag": "\"deserialization relationships\"",
                "priority": 6,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "Relationship deserialization currently looks at the reverse relationship and attempts to assign there, which is probably the wrong approach (it was easier at the time, though!)\r\n\r\nWe should probably just use the regular (not inverse) setter for toOnes. For toManys, we can look for addObject: methods and use those if they exist; otherwise we can use more esoteric processing (like using the inverse setter if it's a one-many, and who knows what if it's a many-many...)",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:59:26Z"
            }
        },
        {
            "ticket": {
                "original_body_html": "<div><p>Local update is mostly covered by updateWithDictionary; remote\nupdate will be a little more involved.</p></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/5",
                "permalink": "feature-add-local-and-remote-update-functionality",
                "updated_at": "2010-03-06T16:55:33Z",
                "project_id": 48029,
                "title": "[feature] Add local and remote update functionality",
                "number": 5,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "Local update is mostly covered by updateWithDictionary; remote update will be a little more involved.",
                "tag": "update",
                "priority": 5,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "Local update is mostly covered by updateWithDictionary; remote update will be a little more involved.",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:55:30Z"
            }
        },
        {
            "ticket": {
                "original_body_html": "<div><p>Implement basic remote creation. Should also add an umbrella\ncreate method which creates a local instance and then goes off and\nperforms the remote request.</p>\n<p>I'm thinking we should keep the local ID nil until the create is\nsuccessful? Since Core Data doesn't associate based on explicit\nIDs, we're probably fine with the explicit ID being nil.</p>\n<p>Or perhaps we should have some sort of \"not-yet-synched\"\nflag?</p></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/4",
                "permalink": "feature-implement-remote-create-functionality",
                "updated_at": "2010-03-06T16:54:25Z",
                "project_id": 48029,
                "title": "[feature] Implement remote create functionality",
                "number": 4,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "Implement basic remote creation. Should also add an umbrella create method which creates a local instance and then goes off and performs the remote request.\r\n\r\nI'm thinking we should keep the local ID nil until the create is successful? Since Core Data doesn't associate based on explicit IDs, we're probably fine with the explicit ID being nil.\r\n\r\nOr perhaps we should have some sort of \"not-yet-synched\" flag?",
                "tag": "create",
                "priority": 4,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "Implement basic remote creation. Should also add an umbrella create method which creates a local instance and then goes off and performs the remote request.\r\n\r\nI'm thinking we should keep the local ID nil until the create is successful? Since Core Data doesn't associate based on explicit IDs, we're probably fine with the explicit ID being nil.\r\n\r\nOr perhaps we should have some sort of \"not-yet-synched\" flag?",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:54:25Z"
            }
        },
        {
            "ticket": {
                "original_body_html": "<div><p>CoreResource objects should generate JSON via serialize method\ncalls.</p>\n<p>May want to add add convenience methods such as toJSON and\ntoXML? We don't want to clash with the JSON category, though (or\ndoes it not matter?)</p></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/3",
                "permalink": "feature-implement-nested-resource-serialization",
                "updated_at": "2010-03-06T16:52:01Z",
                "project_id": 48029,
                "title": "[feature] Implement nested resource serialization",
                "number": 3,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "CoreResource objects should generate JSON via serialize method calls.\r\n\r\nMay want to add add convenience methods such as toJSON and toXML? We don't want to clash with the JSON category, though (or does it not matter?)",
                "tag": "\"serialization json xml\"",
                "priority": 3,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "CoreResource objects should generate JSON via serialize method calls.\r\n\r\nMay want to add add convenience methods such as toJSON and toXML? We don't want to clash with the JSON category, though (or does it not matter?)",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:51:59Z"
            }
        },
        {
            "ticket": {
                "original_body_html": "<div><p>Pre-created \"byId\" templates are currently searched for, but\nsince we've added automatic templating to FetchRequest generation\n(see fetchRequest: method), we can just use that to deal with\ntemplates automatically.</p>\n<pre>\n<code>NSFetchRequest* fetch = [[[self coreManager] managedObjectModel] \n    fetchRequestFromTemplateWithName:[NSString stringWithFormat:@\"%@ById\", self] \n        substitutionVariables:[NSDictionary dictionaryWithObject:resourceId forKey:@\"id\"]\n    ];\n    if (fetch == nil) {\n        fetch = [self fetchRequestWithSort:nil andPredicate:\n            [NSPredicate predicateWithFormat:[NSString stringWithFormat:@\"%@ = %@\", [self localIdField], resourceId]]];\n    }\n    [fetch setFetchLimit:1];</code>\n</pre></div>",
                "url": "http://coreresource.lighthouseapp.com/projects/48029/tickets/2",
                "permalink": "createorupdatewithdictionary-should-templatereuse-byid-fetch-requests-for-efficiency",
                "updated_at": "2010-03-06T16:49:22Z",
                "project_id": 48029,
                "title": "createOrUpdateWithDictionary should template/reuse byId fetch requests for efficiency",
                "number": 2,
                "milestone_due_on": null,
                "creator_id": 89473,
                "latest_body": "Pre-created \"byId\" templates are currently searched for, but since we've added automatic templating to FetchRequest generation (see fetchRequest: method), we can just use that to deal with templates automatically.\r\n\r\n@@@\r\nNSFetchRequest* fetch = [[[self coreManager] managedObjectModel] \r\n    fetchRequestFromTemplateWithName:[NSString stringWithFormat:@\"%@ById\", self] \r\n        substitutionVariables:[NSDictionary dictionaryWithObject:resourceId forKey:@\"id\"]\r\n    ];\r\n    if (fetch == nil) {\r\n        fetch = [self fetchRequestWithSort:nil andPredicate:\r\n            [NSPredicate predicateWithFormat:[NSString stringWithFormat:@\"%@ = %@\", [self localIdField], resourceId]]];\r\n    }\r\n    [fetch setFetchLimit:1];\r\n@@@",
                "tag": "\"performance templates\"",
                "priority": 2,
                "attachments_count": 0,
                "raw_data": null,
                "closed": false,
                "creator_name": "mklaurence (at gmail)",
                "user_id": 89473,
                "assigned_user_id": 89473,
                "original_body": "Pre-created \"byId\" templates are currently searched for, but since we've added automatic templating to FetchRequest generation (see fetchRequest: method), we can just use that to deal with templates automatically.\r\n\r\n@@@\r\nNSFetchRequest* fetch = [[[self coreManager] managedObjectModel] \r\n    fetchRequestFromTemplateWithName:[NSString stringWithFormat:@\"%@ById\", self] \r\n        substitutionVariables:[NSDictionary dictionaryWithObject:resourceId forKey:@\"id\"]\r\n    ];\r\n    if (fetch == nil) {\r\n        fetch = [self fetchRequestWithSort:nil andPredicate:\r\n            [NSPredicate predicateWithFormat:[NSString stringWithFormat:@\"%@ = %@\", [self localIdField], resourceId]]];\r\n    }\r\n    [fetch setFetchLimit:1];\r\n@@@",
                "assigned_user_name": "mklaurence (at gmail)",
                "user_name": "mklaurence (at gmail)",
                "state": "new",
                "milestone_id": null,
                "created_at": "2010-03-06T16:49:18Z"
            }
        }
    ]
}